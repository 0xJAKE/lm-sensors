.\" Copyright 1998, 1999 Adrian Baugh <adrian.baugh@keble.ox.ac.uk>
.\" based on sensors.h, part of libsensors by Frodo Looijaard
.\" libsensors is distributed under the GPL
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" References consulted:
.\"     libsensors source code
.TH libsensors 3  "June 2007" "lm-sensors 3" "Linux Programmer's Manual"
.SH NAME
libsensors \- publicly accessible functions provided by the sensors library
.SH SYNOPSIS
.nf
.B #include <sensors/sensors.h>

.B int sensors_init(FILE *input);
.B void sensors_cleanup(void);
.B int sensors_parse_chip_name(const char *orig_name,
                            \fBsensors_chip_name *res);\fP
.B const char *sensors_get_adapter_name(int bus_nr);
.B char *sensors_get_label(const sensors_chip_name *name, int feature);\fP
.B int sensors_get_value(const sensors_chip_name *name, int feature,
                      \fBdouble *value);\fP
.B int sensors_set_value(const sensors_chip_name *name, int feature,
                      \fBdouble value);\fP
.B int sensors_do_chip_sets(const sensors_chip_name *name);
.B const sensors_chip_name *sensors_get_detected_chips(const sensors_chip_name
                                                    \fB*match, int *nr);\fP
.B const sensors_feature_data *sensors_get_all_features 
             \fB(const sensors_chip_name *name, int *nr);\fP
.B const char *libsensors_version;
.fi
.SH DESCRIPTION
.B int sensors_init(FILE *input);
.br
Load the configuration file and the detected chips list. If this returns a
value unequal to zero, you are in trouble; you can not assume anything will
be initialized properly. If you want to reload the configuration file, call
sensors_cleanup() below before calling sensors_init() again.

.B void sensors_cleanup(void);
.br
Clean-up function: You can't access anything after this, until the next sensors_init() call!
.br

\fBint sensors_parse_chip_name(const char *orig_name,
                            sensors_chip_name *res);\fP
.br
Parse a chip name to the internal representation. Return 0 on succes, <0 on error.

.B const char *sensors_get_adapter_name(int bus_nr);
.br
This function returns the adapter name of a bus number, as used within the
sensors_chip_name structure. If it could not be found, it returns NULL.

\fBchar *sensors_get_label(const sensors_chip_name *name, int feature);\fP
.br
Look up the label which belongs to this chip. Note that chip should not
contain wildcard values! The returned string is newly allocated (free it
yourself). On failure, NULL is returned.
If no label exists for this feature, its name is returned itself.

\fBint sensors_get_value(const sensors_chip_name *name,
                      int feature, double *value);\fP
.br
Read the value of a feature of a certain chip. Note that chip should not contain wildcard values! This function will return 0 on success, and <0 on failure.

\fBint sensors_set_value(const sensors_chip_name *name,
                      int feature, double value);\fP
.br
Set the value of a feature of a certain chip. Note that chip should not contain wildcard values! This function will return 0 on success, and <0 on failure.

.B int sensors_do_chip_sets(const sensors_chip_name *name);
.br
Execute all set statements for this particular chip. The chip may contain wildcards!  This function will return 0 on success, and <0 on failure.

\fBconst sensors_chip_name *sensors_get_detected_chips(const sensors_chip_name
                                                    *match, int *nr);\fP
.br
This function returns all detected chips that match a given chip name,
one by one. If no chip name is provided, all detected chips are returned.
To start at the beginning of the list, use 0 for nr; NULL is returned if
we are at the end of the list. Do not try to change these chip names, as
they point to internal structures!

This structure is used when you want to get all features of a specific chip.
.br
\fBtypedef struct sensors_feature_data {
.br
  const char *name;
.br
  int number;
.br
  sensors_feature_type type;
.br
  int mapping;
.br
  unsigned int flags;
.br
} sensors_feature_data;\fP
.br
The flags field is a bitfield, its value is a combination of
SENSORS_MODE_R (readable), SENSORS_MODE_W (writable) and SENSORS_COMPUTE_MAPPING
(affected by the computation rules of the main feature).

\fBconst sensors_feature_data *sensors_get_all_features
      (const sensors_chip_name *name, int *nr);\fP
.br
This returns all features of a specific chip. They are returned in bunches:
everything with the same mapping is returned just after each other, with
the master feature in front (that feature does not map to itself, but
has SENSORS_NO_MAPPING as mapping field). nr is an internally used variable.
Set it to zero to start again at the begin of the list. If no more features
are found NULL is returned. Do not try to change the returned structure; you
will corrupt internal data structures.

\fBconst char *libsensors_version;\fP
.br
A string representing the version of libsensors.

.SH SEE ALSO
sensors.conf(5)

.SH AUTHOR
Frodo Looijaard and the lm_sensors group
http://www.lm-sensors.org/

