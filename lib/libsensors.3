.\" Copyright (C) 1998, 1999  Adrian Baugh <adrian.baugh@keble.ox.ac.uk>
.\" Copyright (C) 2007, 2009  Jean Delvare <khali@linux-fr.org>
.\" based on sensors.h, part of libsensors by Frodo Looijaard
.\" libsensors is distributed under the GPL
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" References consulted:
.\"     libsensors source code
.TH libsensors 3  "February 2009" "lm-sensors 3" "Linux Programmer's Manual"

.SH NAME
libsensors \- publicly accessible functions provided by the sensors library

.SH SYNOPSIS
.nf
.B #include <sensors/sensors.h>

/* Library initialization and clean-up */
.BI "int sensors_init(FILE *" input ");"
.B void sensors_cleanup(void);
.BI "const char *" libsensors_version ";"

/* Chip name handling */
.BI "int sensors_parse_chip_name(const char *" orig_name ","
.BI "                            sensors_chip_name *" res ");"
.BI "const char *sensors_get_adapter_name(const sensors_bus_id *" bus ");"

/* Chips and features enumeration */
.B const sensors_chip_name *
.BI "sensors_get_detected_chips(const sensors_chip_name *" match ","
.BI "                           int *" nr ");"
.B const sensors_feature *
.BI "sensors_get_features(const sensors_chip_name *" name ","
.BI "                     int *" nr ");"
.B const sensors_subfeature *
.BI "sensors_get_all_subfeatures(const sensors_chip_name *" name ","
.BI "                            const sensors_feature *" feature ","
.BI "                            int *" nr ");"
.B const sensors_subfeature *
.BI "sensors_get_subfeature(const sensors_chip_name *" name ","
.BI "                       const sensors_feature *" feature ","
.BI "                       sensors_subfeature_type " type ");"

/* Features access */
.BI "char *sensors_get_label(const sensors_chip_name *" name ","
.BI "                        const sensors_feature *" feature ");"
.BI "int sensors_get_value(const sensors_chip_name *" name ", int " subfeat_nr ","
.BI "                      double *" value ");"
.BI "int sensors_set_value(const sensors_chip_name *" name ", int " subfeat_nr ","
.BI "                      double " value ");"
.BI "int sensors_do_chip_sets(const sensors_chip_name *" name ");"
.fi

.SH DESCRIPTION
.B sensors_init()
loads the configuration file and the detected chips list. If this returns a
value unequal to zero, you are in trouble; you can not assume anything will
be initialized properly. If you want to reload the configuration file, call
sensors_cleanup() below before calling sensors_init() again.

If FILE is NULL, the default configuration files are used (see the FILES
section below). Most applications will want to do that.

.B sensors_cleanup()
cleans everything up: you can't access anything after this, until the next sensors_init() call!

.B sensors_parse_chip_name()
parses a chip name to the internal representation. Return 0 on success,
<0 on error.

.B sensors_get_adapter_name()
returns the adapter name of a bus number, as used within the
sensors_chip_name structure. If it could not be found, it returns NULL.

.B sensors_get_label()
looks up the label which belongs to this chip. Note that chip should not
contain wildcard values! The returned string is newly allocated (free it
yourself). On failure, NULL is returned.
If no label exists for this feature, its name is returned itself.

.B sensors_get_value()
Reads the value of a subfeature of a certain chip. Note that chip should not
contain wildcard values! This function will return 0 on success, and <0 on
failure.

.B sensors_set_value()
sets the value of a subfeature of a certain chip. Note that chip should not
contain wildcard values! This function will return 0 on success, and <0 on
failure.

.B sensors_do_chip_sets()
executes all set statements for this particular chip. The chip may contain
wildcards!  This function will return 0 on success, and <0 on failure.

.B sensors_get_detected_chips()
returns all detected chips that match a given chip name,
one by one. If no chip name is provided, all detected chips are returned.
To start at the beginning of the list, use 0 for nr; NULL is returned if
we are at the end of the list. Do not try to change these chip names, as
they point to internal structures!

This structure contains information related to a given feature of a
specific chip.
.br
\fBtypedef struct sensors_feature {
.br
	const char *name;
.br
	int number;
.br
	sensors_feature_type type;
.br
} sensors_feature;\fP
.br
There are other member not documented here, which are only meant for libsensors
internal use.

This structure contains information related to a given subfeature of a
specific chip feature.
.br
\fBtypedef struct sensors_subfeature {
.br
	const char *name;
.br
	int number;
.br
	sensors_subfeature_type type;
.br
	int mapping;
.br
	unsigned int flags;
.br
} sensors_subfeature;\fP
.br
The flags field is a bitfield, its value is a combination of
SENSORS_MODE_R (readable), SENSORS_MODE_W (writable) and SENSORS_COMPUTE_MAPPING
(affected by the computation rules of the main feature).

.B sensors_get_features()
returns all main features of a specific chip. nr is an internally
used variable. Set it to zero to start at the begin of the list. If no
more features are found NULL is returned.
Do not try to change the returned structure; you will corrupt internal
data structures.

.B sensors_get_all_subfeatures()
returns all subfeatures of a given main feature. nr is an internally
used variable. Set it to zero to start at the begin of the list. If no
more subfeatures are found NULL is returned.
Do not try to change the returned structure; you will corrupt internal
data structures.

.B sensors_get_subfeature()
returns the subfeature of the given type for a given main feature,
if it exists, NULL otherwise.
Do not try to change the returned structure; you will corrupt internal
data structures.

.B libsensors_version
is a string representing the version of libsensors.

.SH FILES
.I /etc/sensors3.conf
.br
.I /etc/sensors.conf
.RS
The system-wide
.BR libsensors (3)
configuration file. /etc/sensors3.conf is tried first, and if it doesn't exist,
/etc/sensors.conf is used instead.
.RE

.I /etc/sensors.d
.RS
A directory where you can put additional libsensors configuration files.
Files found in this directory will be processed in alphabetical order after
the default configuration file. Files with names that start with a dot are
ignored.
.RE

.SH SEE ALSO
sensors.conf(5)

.SH AUTHOR
Frodo Looijaard and the lm_sensors group
http://www.lm-sensors.org/

